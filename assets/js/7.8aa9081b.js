(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{353:function(e,a,t){"use strict";t.r(a);var v=t(43),c=Object(v.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"api"}},[e._v("API")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/ajv-validator/ajv#api",target:"_blank",rel:"noopener noreferrer"}},[e._v("英文原地址"),t("OutboundLink")],1)]),e._v(" "),t("h2",{attrs:{id:"new-ajv-object-options-object"}},[t("code",[e._v("new Ajv(Object options) -> Object")])]),e._v(" "),t("p",[e._v("创建 Ajv 实例。")]),e._v(" "),t("h2",{attrs:{id:"compile-object-schema-function-object-data"}},[t("code",[e._v(".compile(Object schema) -> Function<Object data>")])]),e._v(" "),t("p",[e._v("生成验证函数并缓存已编译的 schema 以备将来使用。")]),e._v(" "),t("p",[e._v("验证函数返回一个布尔值。该函数拥有"),t("code",[e._v("errors")]),e._v("和"),t("code",[e._v("schema")]),e._v("属性。在最后一次验证期间遇到的错误将被分配给"),t("code",[e._v("errors")]),e._v("属性(如果没有错误，则将其分配为"),t("code",[e._v("null")]),e._v(")。"),t("code",[e._v("schema")]),e._v("属性包含了对原始 schema 的引用。")]),e._v(" "),t("p",[e._v("传递给该方法的 schema 将根据元 schema 进行验证，除非配置项"),t("code",[e._v("validateSchema")]),e._v("的值为"),t("code",[e._v("false")]),e._v("。如果 schema 无效则会抛出错误。参见"),t("a",{attrs:{href:"https://github.com/ajv-validator/ajv#options",target:"_blank",rel:"noopener noreferrer"}},[e._v("配置项"),t("OutboundLink")],1),e._v("。")]),e._v(" "),t("h2",{attrs:{id:"compileasync-object-schema-boolean-meta-function-callback-promise"}},[t("code",[e._v(".compileAsync(Object schema [, Boolean meta] [, Function callback]) -> Promise")])]),e._v(" "),t("p",[t("code",[e._v("compile")]),e._v("方法的异步版本，使用"),t("code",[e._v("options.loadSchema")]),e._v("中的异步函数加载缺少的远程 schema。该函数返回一个"),t("code",[e._v("resolve")]),e._v("结果为验证函数的 Promise。传递给"),t("code",[e._v("compileAsync")]),e._v("的可选函数参数将被调用，它有两个参数：error (或 null) 以及验证函数。在下面情况下，将返回"),t("code",[e._v("reject")]),e._v("结果的 Promise：")]),e._v(" "),t("ul",[t("li",[e._v("丢失的 schema 无法加载("),t("code",[e._v("loadSchema")]),e._v("返回"),t("code",[e._v("reject")]),e._v("的 Promise)。")]),e._v(" "),t("li",[e._v("加载的 schema 存在引用缺失，且无法解析引用。")]),e._v(" "),t("li",[e._v("schema (或某些加载/引用的 schema)无效。")])]),e._v(" "),t("p",[e._v("该函数编译 schema 并加载第一个缺失的 schema (或元 schema )，直到加载完所有缺失的 schema 为止。")]),e._v(" "),t("p",[e._v("您可以通过传递"),t("code",[e._v("true")]),e._v("作为第二个参数来异步编译元 schema 。")]),e._v(" "),t("p",[e._v("参见"),t("a",{attrs:{href:"https://github.com/ajv-validator/ajv#asynchronous-schema-compilation",target:"_blank",rel:"noopener noreferrer"}},[e._v("异步编译"),t("OutboundLink")],1),e._v("示例。")]),e._v(" "),t("h2",{attrs:{id:"validate-object-schema-string-key-string-ref-data-boolean"}},[t("code",[e._v(".validate(Object schema|String key|String ref, data) -> Boolean")])]),e._v(" "),t("p",[e._v("使用传入的 schema 验证数据(它将被编译和缓存)。")]),e._v(" "),t("p",[e._v("您可以使用之前传递给"),t("code",[e._v("addSchema")]),e._v("的键而不是 schema (如果 schema 或以前解析的引用中存在的 schema id)。")]),e._v(" "),t("p",[e._v("验证错误将存储在 Ajv 实例的"),t("code",[e._v("errors")]),e._v("属性中(如果没有错误，则为"),t("code",[e._v("null")]),e._v(")。")]),e._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[e._v("请注意")]),e._v(" "),t("p",[e._v("每次调用该方法时，都会覆盖错误，因此如果以后想要使用它们，需要将它们复制到另一个变量中。")])]),e._v(" "),t("p",[e._v("如果 schema 是异步的(它在最顶层拥有"),t("code",[e._v("$async")]),e._v("关键字)，它将返回一个 Promise。参见"),t("a",{attrs:{href:"https://github.com/ajv-validator/ajv#asynchronous-validation",target:"_blank",rel:"noopener noreferrer"}},[e._v("异步验证"),t("OutboundLink")],1),e._v("。")]),e._v(" "),t("h2",{attrs:{id:"addschema-array-object-object-schema-string-key-ajv"}},[t("code",[e._v(".addSchema(Array<Object>|Object schema [, String key]) -> Ajv")])]),e._v(" "),t("p",[e._v("向验证器实例添加 schema 。此方法不编译 schema (但仍然验证)。因此，依赖关系可以以任何顺序添加，并支持循环依赖。它还可以防止作为其他 schema 容器但并非作为一个整体使用的 schema 发生不必要地编译。")]),e._v(" "),t("p",[e._v("可以传入 schema 数组(schema 应该有id)，第二个参数将被忽略。")]),e._v(" "),t("p",[e._v("可以传递可用于引用 schema 的键，如果 schema 中没有id，则将作为 schema 的 id 使用。如果没有传递键，则将使用 schema id作为键。")]),e._v(" "),t("p",[e._v("一旦添加了 schema ，就可以在其他 schema 中(以及其中的所有引用)引用它，并用于验证数据。")]),e._v(" "),t("p",[e._v("虽然"),t("code",[e._v("addSchema")]),e._v("不编译 schema ，但不需要显式编译 ———— 该 schema 将在第一次使用时进行编译。")]),e._v(" "),t("p",[e._v("默认情况下，schema 在被添加之前会根据元 schema 进行验证，如果 schema 没有通过验证，就会抛出异常。这种行为由配置项"),t("code",[e._v("validateSchema")]),e._v("控制。")]),e._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[e._v("请注意")]),e._v(" "),t("p",[e._v("Ajv 中所有前缀为"),t("code",[e._v("add*")]),e._v("和"),t("code",[e._v("remove*")]),e._v("的方法都可以使用链式调用。")]),e._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" validate "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Ajv")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("addSchema")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("schema"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("addFormat")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("name"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" regex"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("getSchema")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("uri"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])])]),e._v(" "),t("h2",{attrs:{id:"addmetaschema-array-object-object-schema-string-key-ajv"}},[t("code",[e._v(".addMetaSchema(Array<Object>|Object schema [, String key]) -> Ajv")])]),e._v(" "),t("p",[e._v("添加可用于验证其他 schema 的元 schema 。该函数应该替代"),t("code",[e._v("addSchema")]),e._v("，因为可能有实例配置项会不正确地编译一个元 schema(目前它是配置项"),t("code",[e._v("removeAdditional")]),e._v(")。")]),e._v(" "),t("p",[e._v("没有必要显式地添加 "),t("a",{attrs:{href:"http://json-schema.org/draft-07/schema",target:"_blank",rel:"noopener noreferrer"}},[e._v("draft-07 元 schema"),t("OutboundLink")],1),e._v(" —— 它是默认添加的，除非配置项"),t("code",[e._v("meta")]),e._v("的值为"),t("code",[e._v("false")]),e._v("。只有当您有一个更改过的元 schema，想要使用它来验证您的 schema 时，您才需要使用它。参见"),t("code",[e._v("validateSchema")]),e._v("。")]),e._v(" "),t("h2",{attrs:{id:"validateschema-object-schema-boolean"}},[t("code",[e._v(".validateSchema(Object schema) -> Boolean")])]),e._v(" "),t("p",[e._v("验证 schema。由于 JSON schema 标准中的"),t("code",[e._v("uri")]),e._v("格式不一致，应该使用该方法验证 schema 而不是"),t("code",[e._v("validate")]),e._v("。")]),e._v(" "),t("p",[e._v("默认在添加 schema 时自动调用此方法，因此很少需要直接使用它。")]),e._v(" "),t("p",[e._v("如果 schema 并没有"),t("code",[e._v("$schema")]),e._v("属性，它将根据 draft 6 的元 schema 进行验证("),t("code",[e._v("meta")]),e._v("配置项的值不应该是"),t("code",[e._v("false")]),e._v(")。")]),e._v(" "),t("p",[e._v("如果 schema 拥有"),t("code",[e._v("$schema")]),e._v("属性，那么使用拥有该"),t("code",[e._v("id")]),e._v("的 schema (应该在前面添加)来验证传入的 schema。")]),e._v(" "),t("p",[e._v("错误会放到"),t("code",[e._v("ajv.errors")]),e._v("中。")]),e._v(" "),t("h2",{attrs:{id:"getschema-string-key-function-object-data"}},[t("code",[e._v(".getSchema(String key) -> Function<Object data>")])]),e._v(" "),t("p",[e._v("通过传递给"),t("code",[e._v("addSchema")]),e._v("的键或其完整引用(id)检索以前用"),t("code",[e._v("addSchema")]),e._v("添加的已编译 schema。返回的验证函数拥有"),t("code",[e._v("schema")]),e._v("属性，它是对原始 schema 的引用。")]),e._v(" "),t("h2",{attrs:{id:"removeschema-object-schema-string-key-string-ref-regexp-pattern-ajv"}},[t("code",[e._v(".removeSchema([Object schema|String key|String ref|RegExp pattern]) -> Ajv")])]),e._v(" "),t("p",[e._v("移除添加/缓存的 schema。即使 schema 被其他 schema 引用，它也可以安全地删除，因为有本地引用了。")]),e._v(" "),t("p",[e._v("schema 可以用以下方法移除：")]),e._v(" "),t("ul",[t("li",[e._v("传入"),t("code",[e._v("addSchema")]),e._v("的键。")]),e._v(" "),t("li",[e._v("其完全引用(id)。")]),e._v(" "),t("li",[e._v("应匹配 schema 或键的正则表达式(元 schema 不会被删除)。")]),e._v(" "),t("li",[e._v("实际的 schema 对象，它会被稳定地字符串化以从缓存中移除。")])]),e._v(" "),t("p",[e._v("如果没有传递任何参数，除了元 schema 外，所有 schema 都将被删除，缓存也会被清空。")]),e._v(" "),t("h2",{attrs:{id:"addformat-string-name-string-regexp-function-object-format-ajv"}},[t("code",[e._v(".addFormat(String name, String|RegExp|Function|Object format) -> Ajv")])]),e._v(" "),t("p",[e._v("添加自定义格式以验证字符串或数字。它还可以用于替换 Ajv 实例中的预定义格式。")]),e._v(" "),t("p",[e._v("字符串会被转换为正则。")]),e._v(" "),t("p",[e._v("函数应该返回"),t("code",[e._v("true")]),e._v("或"),t("code",[e._v("false")]),e._v("的验证结果。")]),e._v(" "),t("p",[e._v("如果传入对象，那么它应该具有"),t("code",[e._v("validate")]),e._v("、"),t("code",[e._v("compare")]),e._v("和"),t("code",[e._v("async")]),e._v("属性：")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",{staticStyle:{"text-align":"center"}},[e._v("对象属性")]),e._v(" "),t("th",[e._v("描述")])])]),e._v(" "),t("tbody",[t("tr",[t("td",{staticStyle:{"text-align":"center"}},[t("code",[e._v("validate")])]),e._v(" "),t("td",[e._v("字符串、正则或如上所述的函数。")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[t("code",[e._v("compare")])]),e._v(" "),t("td",[e._v("可选的比较函数，它接受两个字符串，并根据格式的含义对它们进行比较。此函数与关键字"),t("code",[e._v("formatMaximum/formatMinimum")]),e._v("(在"),t("code",[e._v("ajv-keywords")]),e._v("包中定义)一起使用。如果第一个值大于第二个值，它应该返回"),t("code",[e._v("1")]),e._v("，如果它小于它应该返回"),t("code",[e._v("-1")]),e._v("，如果它等于它应该返回"),t("code",[e._v("0")]),e._v("。")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[t("code",[e._v("async")])]),e._v(" "),t("td",[e._v("可选的"),t("code",[e._v("true")]),e._v("值，如果验证函数式异步的(无论它是编译或传入的验证属性)；在这种情况下，它应该返回一个 Promise，该 Promise 的值为"),t("code",[e._v("true")]),e._v("或"),t("code",[e._v("false")]),e._v("。这个选项在“宏(macro)”和“内联(inline)”关键字的情况下被忽略。")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[t("code",[e._v("errors")])]),e._v(" "),t("td",[e._v("选的布尔值或字符串"),t("code",[e._v("“full”")]),e._v("，用于指示关键字是否返回错误。如果没有设置该属性，Ajv 将决定验证失败时是否设置错误。")])])])]),e._v(" "),t("p",[e._v("编译(compile)、宏(macro)和内联(inline)是互斥的，一次只能使用一个。"),t("code",[e._v("validate")]),e._v("可以单独使用，也可以与它们一起使用，以支持"),t("code",[e._v("$data")]),e._v("引用。")]),e._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[e._v("请注意")]),e._v(" "),t("p",[e._v("如果关键字是在其定义中验证数据类型不同的类型，验证函数将不会被调用(且扩展宏也不会被使用)，所以不需要检查数据类型内部验证函数或宏函数返回的内部 schema (除非你想执行一个特定的类型和出于某种原因不想使用一个单独的"),t("code",[e._v("type")]),e._v("关键字)。与标准关键字的工作方式相同，如果关键字不适用于被验证的数据类型，则该关键字的验证将通过。")]),e._v(" "),t("p",[e._v("参见"),t("a",{attrs:{href:"https://github.com/ajv-validator/ajv#defining-custom-keywords",target:"_blank",rel:"noopener noreferrer"}},[e._v("自定义关键字"),t("OutboundLink")],1)])]),e._v(" "),t("h2",{attrs:{id:"getkeyword-string-keyword-object-boolean"}},[t("code",[e._v(".getKeyword(String keyword) -> Object|Boolean")])]),e._v(" "),t("p",[e._v("返回自定义关键字的定义。如果是预定义关键字返回"),t("code",[e._v("true")]),e._v("，如果是未知关键字返回则"),t("code",[e._v("false")]),e._v("。")]),e._v(" "),t("h2",{attrs:{id:"removekeyword-string-keyword-ajv"}},[t("code",[e._v(".removeKeyword(String keyword) -> Ajv")])]),e._v(" "),t("p",[e._v("删除自定义或预定义的关键字，以便重新定义它们。")]),e._v(" "),t("p",[e._v("虽然这种方法可以用来扩展预定义的关键字，但它也可以用来完全改变它们的意思 —— 它可能会导致意想不到的结果。")]),e._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[e._v("请注意")]),e._v(" "),t("p",[e._v("在关键字被删除之前编译的 schema 将继续工作，不需要做任何更改。要重新编译 schema，请使用"),t("code",[e._v("removeSchema")]),e._v("方法并再次编译它们。")])]),e._v(" "),t("h2",{attrs:{id:"errorstext-array-object-errors-object-options-string"}},[t("code",[e._v(".errorsText([Array<Object> errors [, Object options]]) -> String")])]),e._v(" "),t("p",[e._v("返回字符串中包含所有错误的文本。")]),e._v(" "),t("p",[e._v("配置项有"),t("code",[e._v("separator")]),e._v("属性(默认情况下用"),t("code",[e._v("“，”")]),e._v("分隔错误的字符串)和"),t("code",[e._v("dataVar")]),e._v("属性(默认情况下 dataPath 前缀为“data”的变量名)。")])])}),[],!1,null,null,null);a.default=c.exports}}]);